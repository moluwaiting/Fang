# C++笔记（[Markdown教程](https://www.zybuluo.com/mdeditor)）

## 1.数组
>* 数组大小固定不变，在初始化的时候声明，不能随意增添内容；
>* vector则是动态的可以增加减少内容，并且不固定大小；
>* 在某些情况下运行的很好，但是灵活性较差。
>* 不可以讲述组的内容直接拷贝给另一个数组，应该一个一个的拷贝，但是一些编译器可能可以一次性拷贝，但是不支持这样的做法。
```C++
int a[10];//必须是常量
const int const_num;    int b[const_num];
int a[5]={1,2,3} //此时，剩下的都被初始化为默认的值0
string b[5]={"fang","ren","jie"} //剩下的都被初始化为默认的""
int *a[10];// 表示一个数组，其中十个值为十个整型指针；指针数组
int &a[10];//错误，不存在引用的数组
int (*a)[10]=&arr;//a指向一个含有10个整数的数组；数组指针
int (&a)[10]=arr;//a表示一个含有10整数数组的引用
```

## 2.C 风格字符串
>* 

## 3.一些基础知识
##### 变量以及基本类型：1个字(word)一般为4或8字节(byte)，1字节8位(bit)

##### 与或非：&&      ||     ！      条件运算符：   ?:

char   字符：8位   相当于一个机器字节的大小

wchar_t   宽字符：16位

short int   短整型：16位

int 整型：16位

long int 长整型：32位

long long int  长长整型：64位

float 单精度浮点数：6位有效数字

double 双精度浮点数：10位有效数字

long double 扩展精度浮点数：10位有效数字

## 4.一些关键字

> * **decltype**：主要用于推断类型，类似auto



## 5.运算符基础

> * 一元运算符，二元运算符以及三元运算符等
> * 组合运算符以及运算顺序
> * 运算对象转换，不同类型的对象转化为同一类型的对象
```C++
cout<<6+3*4/2<<endl;//输出14
cin>>c1>>c2;//先读入c1，后读入c2
int num = 42;
num%3.14;//错误，取余运算符必须是除以整数类型

```
>* 成员访问运算符
```C++
string s1 = "fang ren jie ",*s2;
s2 = &s1;
s2->size();
(*s2).size();//对于指针而言，上面两个是等价的
```

>* 条件运算符
```C++
string final = (grade<60) ? "fail":"pass";
string final = (grade>90) ? "good":((grade<60) ?"fail":"pass");
//嵌套条件运算符，代码的可读性下降
```

> * 位运算符：作用于整数类型的运算对象，把对象看成是二进制位的集合。提供检查和设置二进制位的功能。
```C++
假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：
A = 0011 1100
B = 0000 1101
A&B = 0000 1100 //同时存在1，叫做and运算符
A|B = 0011 1101 //其中一个存在1，叫做or运算符
A^B = 0011 0001 //存于于其中一个而不存在于另一个
~A  = 1100 0011	//全部取反，也叫补码运算符
A = A<<2;//二进制的数左移两位反之则右移
```

> * 移位运算符（IO运算符）cout<<10<<endl;
>
> * *sizeof运算符* 返回一条表达式或一个类型名字所占的字节数
```C++
int fang = 1;
cout<<sizeof(fang)<<endl;//结果输出4,表示一个int 型的数据占有四个字节，
```

> * 类型转换
```C++
int fang = 1+3.21;//结果会损失精度,这里可以直接使用auto关键字
```

## 6.语句

### 6.1 简单语句

```C++
if(){  
}
else if(){ 
}
else{
}

while(){
    
}

switch(chr){//这里进行判断
    case 'a':
        i++;
        break;
    case 'b':
        j++;
        break;
    default://如果一个都匹配不上的话，就使用执行default后的语句
        k++;
        break;
}

vector<int> vec = {0,1,2,3,4,5,6,7,8,9};
for (auto &i:vec){//范围for语句
	i = i*i;
}

```

### 6.2 跳转语句

> * break：负责终止离它最近的while，do while,for,switch等
> * continue：终止最近循环中的当前循环，并立即开始下一次循环，一般只出现与for,while,do while中
> * goto语句，尽量不要在程序中使用这个语句
> * try语句块以及异常处理：程序的某部分检测到无法处理的问题时，需要用到异常处理

```C++


throw //表达式:检测异常，抛出异常
    throw runtime_error("数据一致！")
    
try //处理异常,结合catch块
    #include<stdexcept>//头文件，定义了几种常见的异常类
    #include <iostream>
    using namespace std;
    int main()
    {
        double m ,n;
        cin >> m >> n;
        try {
            cout << "before dividing." << endl;
            if( n == 0)
                throw -1; //抛出int类型异常
            else
                cout << m / n << endl;
            cout << "after dividing." << endl;
        }
        catch(double d) {
            cout << "catch(double) " << d <<  endl;
        }
        catch(int e) {//与这里的整型匹配
            cout << "catch(int) " << e << endl;
        }
        cout << "finished" << endl;
        return 0;
    }
```

#  7.函数

### 7.1函数基础

#### 典型的函数包括有：返回类型，函数名，0至多个形参组成的**列表**，函数体

#### 形参：函数被定义时函数体内参数

#### 实参：主函数中调用函数传入的参数值，实参对形参进行初始化

#### 函数的返回值：返回类型不能是数组或函数，但是可以是指向数组或者函数的指针；

#### 对象的声明周期：局部变量在函数被调用时创建，在函数执行结束时被销毁

#### 自动对象：形参就是一种自动对象，调用函数的时候创建，结束时销毁；

#### 局部静态对象：一些时候需要局部变量的生命周期贯穿函数调用及其结束之后的时间，因此，引入局部静态对象，初始化之后，整个程序结束才会销毁。

```C++
//求阶乘的函数
int fact(int num){
    int sum = 1;
    while(num>1){
        sum = sum*num;
        num--;
    }
}
//静态局部对象static
static int num;
```

#### 函数的声明：必须在使用之前声明，可以声明多次，但是只能定义一次；如果没用到的话，可以只声明而不定义。

#### 声明和定义的区别：声明没有函数体，其他的和函数定义完全一样。

#### 一般的，在头文件中对函数进行声明，而在源文件中对函数进行定义

### 7.2参数传递

#### **引用传递**（实参被引用传递，函数被传引用调用）：形参是引用类型时，形参就和实参进行绑定，形参的值直接影响实参的值；

#### **值传递**（实参被值传递，函数被传值调用）：形参是非引用类型时，实参的值拷贝给形参，形参变化不会影响到实参，形参与实参独立；

#### 指针形参：函数的形参是一个指针，直接指向实参的地址，一般在C中使用较多，C++中一般建议使用引用传递。

#### 使用引用而避免拷贝：直接拷贝的话，会浪费时间

```C++
bool isShorter(const string &s1,const string &s2){
    return s1.size()>s2.size();
}
//这里使用const，把s1和s2定义为常量，是防止函数内部改变了s1和s2的值，直接使用引用，直接比较s1和s2，无需拷贝，节省了时间
```

#### 函数中引用形参：函数只能return一个值，但是使用引用形参可以返回调用函数所产生的额外信息。

#### 可以用一个非常量来初始化一个常量，但是反过来不行。

#### 含有可变形参的函数：1.所有的形参类型都相同的时候，使用initailizer_list标准库类型；2.实参的类型不同时，可以编写特殊的函数，即可变参数模板。

#### 对于initializer_list，需要包含同名的头文件，

#### 尾置返回类型：

```C++
auto func(int i) -> int(*)[10];
```

### 7.3函数重载

#### 同一作用域内的函数名字相同，但是形参列表不同，就称为**重载**。（**main函数不能进行重载**）

